// Generated by CoffeeScript 1.6.3
(function() {
  var Level, preload, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.VAS || (window.VAS = {});

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  preload = null;

  window.VAS.Level = Level = (function(_super) {
    __extends(Level, _super);

    Level.BLOCK_SIZE = 70;

    Level.TERMINAL_VEL = 500;

    function Level(leveldef) {
      var i, _i, _ref;
      this.leveldef = leveldef;
      this.initialize();
      preload = root.preload;
      this.completed = false;
      this.layers = [];
      this.objects = [];
      this.statics = [];
      this.width = Level.BLOCK_SIZE * 20;
      this.height = Level.BLOCK_SIZE * 10;
      this.gravity = 1000;
      this.levelScore = this.maxprogress = 0;
      this.createLevel();
      for (i = _i = 0, _ref = this.layers.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.addChild(this.layers[i]);
      }
    }

    Level.prototype.createLevel = function() {
      var background, img, obj, water, x, y, _i, _j, _ref, _ref1, _ref2, _results;
      if (this.leveldef != null) {
        this.width = this.leveldef.data[0].length * Level.BLOCK_SIZE;
        this.height = this.leveldef.data.length * Level.BLOCK_SIZE;
        background = new createjs.Container;
        background.width = this.width;
        background.height = this.height;
        this.layers.push(background);
        y = background.height - Level.BLOCK_SIZE * 0.5;
        img = {};
        x = 70 * Math.random() * 5;
        while (x < this.width) {
          img = new createjs.Bitmap(preload.getResult(Math.random() > 0.5 ? 'hill-short' : 'hill-long'));
          background.addChild(img);
          img.x = x;
          img.y = y - img.image.height;
          x += 70 * Math.random() * 5;
        }
        background = new createjs.Container;
        background.width = this.width * 0.8;
        background.height = this.height;
        this.layers.push(background);
        y = Level.BLOCK_SIZE * 2;
        x = 70 * Math.random() * 5;
        while (x < this.width) {
          img = new createjs.Bitmap(preload.getResult("cloud-" + (parseInt(Math.random() * 3 + 1))));
          background.addChild(img);
          img.x = x;
          img.y = y - img.image.height + Math.random() * Level.BLOCK_SIZE;
          x += 70 * Math.random() * 5;
        }
        background = new createjs.Container;
        background.width = this.width * 0.9;
        background.height = this.height;
        this.layers.push(background);
        water = preload.getResult('water');
        for (x = _i = 0, _ref = background.width, _ref1 = Level.BLOCK_SIZE; _ref1 > 0 ? _i <= _ref : _i >= _ref; x = _i += _ref1) {
          img = new createjs.Bitmap(water);
          background.addChild(img);
          img.x = x;
          img.y = this.height - water.height;
        }
        this.objlayer = new createjs.Container;
        this.objlayer.width = this.width;
        this.objlayer.height = this.height;
        this.layers.push(this.objlayer);
        this.player = new VAS.Player(preload);
        this.addObject(this.player);
        this.resetPlayer();
        if (this.leveldef != null) {
          _results = [];
          for (y = _j = 0, _ref2 = this.height / Level.BLOCK_SIZE; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; y = 0 <= _ref2 ? ++_j : --_j) {
            if (y >= this.leveldef.data.length) {
              continue;
            }
            _results.push((function() {
              var _k, _ref3, _results1;
              _results1 = [];
              for (x = _k = 0, _ref3 = this.width / Level.BLOCK_SIZE; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; x = 0 <= _ref3 ? ++_k : --_k) {
                if (x >= this.leveldef.data[y].length) {
                  continue;
                }
                obj = {};
                switch (this.leveldef.data[y][x]) {
                  case 'g':
                    obj = new VAS.Block(preload.getResult('ground'));
                    this.addStatic(obj);
                    break;
                  case 'b':
                    obj = new VAS.Block(preload.getResult('block'));
                    this.addStatic(obj);
                    break;
                  case 'r':
                    obj = new VAS.Block(preload.getResult('crate'));
                    this.addStatic(obj);
                    break;
                  case 'c':
                    this.addObject(obj = new VAS.Coin);
                    break;
                  case 'f':
                    this.addObject(obj = new VAS.Enemy(VAS.Enemy.ENEMY_FLY));
                    break;
                  case 's':
                    this.addObject(obj = new VAS.Enemy(VAS.Enemy.ENEMY_SLIME));
                }
                if (obj != null) {
                  obj.x = x * Level.BLOCK_SIZE + (Level.BLOCK_SIZE - obj.width) / 2;
                  _results1.push(obj.y = y * Level.BLOCK_SIZE);
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(this));
          }
          return _results;
        } else {
          return this.generateRandomLevel();
        }
      }
    };

    Level.prototype.generateRandomLevel = function() {
      var test, testBlock, x;
      x = 0;
      while (x < this.width) {
        testBlock = new VAS.Block(preload.getResult('ground'));
        testBlock.x = x;
        testBlock.y = this.height - testBlock.height;
        x += Level.BLOCK_SIZE * (1 + parseInt(Math.random() * 3));
      }
      test = new VAS.Enemy(VAS.Enemy.ENEMY_SLIME);
      this.addObject(test);
      test.x = Level.BLOCK_SIZE * 10;
      test.y = this.height - Level.BLOCK_SIZE * 3;
      test = new VAS.Enemy(VAS.Enemy.ENEMY_FLY);
      this.addObject(test);
      test.x = Level.BLOCK_SIZE * 12;
      test.y = this.height - Level.BLOCK_SIZE * 2;
      test = new VAS.Coin;
      this.addObject(test);
      test.x = Level.BLOCK_SIZE * 8;
      test.y = Level.BLOCK_SIZE * 7;
      test = new VAS.Block(preload.getResult('crate'));
      this.addObject(test);
      test.x = Level.BLOCK_SIZE * 3;
      return test.y = Level.BLOCK_SIZE * 7;
    };

    Level.prototype.tick = function(delta) {
      var layer, move, nomove, obj, obj_result, other, other_result, st, static_result, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      _ref = this.objects;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (typeof obj.update === "function") {
          obj.update(delta);
        }
        if (!obj.nogravity) {
          obj.vY += this.gravity * delta;
        }
        if (obj.vY > Level.TERMINAL_VEL) {
          obj.vY = Level.TERMINAL_VEL;
        }
        obj.y += obj.vY * delta;
        if (obj.y + obj.height > this.height && !obj.isDead) {
          if (obj instanceof VAS.Player || obj instanceof VAS.Enemy) {
            obj.isDead = true;
          } else {
            obj.y = this.height - obj.height;
            obj.vY = 0;
          }
        } else if (obj.isDead && obj.y > this.height) {
          if (obj instanceof VAS.Player) {
            this.resetPlayer();
          } else {
            obj.isRemove = true;
          }
        }
        if (obj.isDead) {
          continue;
        }
        obj.x += obj.vX * delta;
        if (obj.x < 0) {
          obj.x = 0;
          if (typeof obj.collideSide === "function") {
            obj.collideSide();
          }
        }
        if (obj.x + obj.width > this.width) {
          if (obj === this.player) {
            if (obj.x + obj.width * 0.5 > this.width) {
              this.completed = true;
            }
          } else {
            obj.x = this.width - obj.width;
          }
          if (typeof obj.collideSide === "function") {
            obj.collideSide();
          }
        }
        _ref1 = this.objects.slice(this.objects.indexOf(obj) + 1);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          other = _ref1[_j];
          if (this.collideRect(obj, other)) {
            if (((obj.canCollide != null) && !obj.canCollide(other)) || ((other.canCollide != null) && !other.canCollide(obj))) {
              continue;
            }
            obj_result = (obj.collide != null) && !obj.collide(other);
            other_result = (other.collide != null) && !other.collide(obj);
            if (obj_result || other_result) {
              continue;
            }
            move = nomove = null;
            if (obj === this.player) {
              move = obj;
              nomove = other;
            } else if (other === this.player) {
              move = other;
              nomove = obj;
            } else if (obj instanceof VAS.Block && !(other instanceof VAS.Block)) {
              move = other;
              nomove = obj;
            } else if (other instanceof VAS.Block && !(obj instanceof VAS.Block)) {
              move = obj;
              nomove = other;
            }
            this.doCollide(move, nomove);
          }
        }
      }
      _ref2 = this.objects;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        obj = _ref2[_k];
        if (obj != null ? obj.isRemove : void 0) {
          this.removeObject(obj);
        }
      }
      _ref3 = this.objects;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        obj = _ref3[_l];
        if (obj.isDead) {
          continue;
        }
        _ref4 = this.statics;
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          st = _ref4[_m];
          if (this.collideRect(obj, st)) {
            if ((obj.canCollide != null) && !obj.canCollide(st)) {
              continue;
            }
            obj_result = (obj.collide != null) && !obj.collide(st);
            static_result = (st.collide != null) && !st.collide(obj);
            if (obj_result || static_result) {
              continue;
            }
            this.doCollide(obj, st);
          }
        }
      }
      _ref5 = this.statics;
      for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
        st = _ref5[_n];
        if (st.isRemove) {
          this.removeStatic(st);
        }
      }
      _ref6 = this.layers;
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        layer = _ref6[_o];
        if (layer.width !== this.width) {
          if (this.player.x < canvasWidth * 0.5) {
            layer.x = 0;
          } else if (this.player.x > this.width - canvasWidth * 0.5) {
            layer.x = this.width - layer.width;
          } else {
            layer.x = (this.player.x - canvasWidth * 0.5) / (this.width - canvasWidth) * (this.width - layer.width);
          }
        }
      }
      if (this.player.x + this.player.width * 0.5 > this.maxprogress) {
        this.maxprogress = this.player.x + this.player.width * 0.5;
      }
      return this.levelScore = this.maxprogress;
    };

    Level.prototype.doCollide = function(move, nomove) {
      var dx, dx_left, dx_right, dy, dy_bot, dy_top;
      if ((move == null) || (nomove == null)) {
        return;
      }
      dx = dy = 0;
      dx_left = nomove.x + nomove.collideRect.x - (move.x + move.collideRect.x + move.collideRect.width);
      dx_right = (nomove.x + nomove.collideRect.x + nomove.collideRect.width) - (move.x + move.collideRect.x);
      dx = dx_left;
      if (Math.abs(dx_left) > Math.abs(dx_right)) {
        dx = dx_right;
      }
      dy_top = nomove.y + nomove.collideRect.y - (move.y + move.collideRect.y + move.collideRect.height);
      dy_bot = (nomove.y + nomove.collideRect.y + nomove.collideRect.height) - (move.y + move.collideRect.y);
      dy = dy_top;
      if (Math.abs(dy_top) > Math.abs(dy_bot)) {
        dy = dy_bot;
      }
      if (Math.abs(dy) <= Math.abs(dx) || (dy < 0 && dy > -5)) {
        move.y += dy;
        if (dy < 0 && move.vY > 0) {
          move.vY = 0;
          if (typeof move.collideGround === "function") {
            move.collideGround();
          }
        }
        if (dy > 0 && move.vY < 0) {
          return move.vY = 0;
        }
      } else {
        move.x += dx;
        move.vX = 0;
        if (typeof move.collideSide === "function") {
          move.collideSide();
        }
        return typeof nomove.collideSide === "function" ? nomove.collideSide() : void 0;
      }
    };

    Level.prototype.collideRect = function(obj1, obj2) {
      if (obj1.collideRect == null) {
        obj1.collideRect = {
          x: 0,
          y: 0,
          width: obj1.width,
          height: obj1.height
        };
      }
      if (obj2.collideRect == null) {
        obj2.collideRect = {
          x: 0,
          y: 0,
          width: obj2.width,
          height: obj2.height
        };
      }
      return !(obj1.x + obj1.collideRect.x + obj1.collideRect.width < obj2.x + obj2.collideRect.x || obj1.x + obj1.collideRect.x > obj2.x + obj2.collideRect.x + obj2.collideRect.width || obj1.y + obj1.collideRect.y + obj1.collideRect.height < obj2.y + obj2.collideRect.y || obj1.y + obj1.collideRect.y > obj2.y + obj2.collideRect.y + obj2.collideRect.height);
    };

    Level.prototype.addObject = function(obj) {
      var _ref;
      this.objects.push(obj);
      if ((_ref = this.objlayer) != null) {
        _ref.addChild(obj);
      }
      if (obj.vX == null) {
        obj.vX = 0;
      }
      if (obj.vY == null) {
        return obj.vY = 0;
      }
    };

    Level.prototype.removeObject = function(obj) {
      this.objlayer.removeChild(obj);
      return this.objects.splice(this.objects.indexOf(obj), 1);
    };

    Level.prototype.addStatic = function(obj) {
      var _ref;
      this.statics.push(obj);
      return (_ref = this.objlayer) != null ? _ref.addChild(obj) : void 0;
    };

    Level.prototype.removeStatic = function(obj) {
      this.objlayer.removeChild(obj);
      return this.statics.splice(this.statics.indexOf(obj), 1);
    };

    Level.prototype.resetPlayer = function() {
      this.player.resetStates();
      this.player.x = this.player.width;
      return this.player.y = 0;
    };

    return Level;

  })(createjs.Container);

}).call(this);

/*
//@ sourceMappingURL=Level.map
*/
