// Generated by CoffeeScript 1.6.3
(function() {
  var Enemy,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.VAS || (window.VAS = {});

  window.VAS.Enemy = Enemy = (function(_super) {
    var COLLIDERECTS;

    __extends(Enemy, _super);

    Enemy.ENEMY_SLIME = 0;

    Enemy.ENEMY_FLY = 1;

    COLLIDERECTS = [
      {
        x: 5,
        y: 0,
        width: 42,
        height: 28
      }, {
        x: 15,
        y: 0,
        width: 36,
        height: 32
      }
    ];

    function Enemy(type) {
      var normal, spriteSheet;
      this.type = type;
      normal = {};
      switch (this.type) {
        case Enemy.ENEMY_SLIME:
          normal = preload.getResult('slime');
          break;
        case Enemy.ENEMY_FLY:
          normal = preload.getResult('fly');
      }
      console.log(normal);
      spriteSheet = new createjs.SpriteSheet({
        images: [normal],
        frames: {
          width: normal.width,
          height: normal.height / 4,
          regX: normal.width / 2,
          regY: 0
        },
        animations: {
          move: [0, 1, 'move', 3],
          dead: 2
        }
      });
      createjs.SpriteSheetUtils.addFlippedFrames(spriteSheet, true, false, false);
      this.initialize(spriteSheet);
      this.width = this.spriteSheet.getFrame(0).rect.width;
      this.height = this.spriteSheet.getFrame(0).rect.height;
      this.regX = -1 * this.width / 2;
      this.regY = 0;
      this.isDead = this.facingRight = false;
      this.moveSpeed = 100;
      if (this.type === Enemy.ENEMY_FLY) {
        this.nogravity = true;
        this.pausetime = 500;
        this.pausetimer = 0;
        this.movetimer = 0;
        this.goingDown = true;
      }
      this.collideRect = {
        x: type < COLLIDERECTS.length ? COLLIDERECTS[type].x : 0,
        y: type < COLLIDERECTS.length ? COLLIDERECTS[type].y : 0,
        width: type < COLLIDERECTS.length ? COLLIDERECTS[type].width : this.width,
        height: type < COLLIDERECTS.length ? COLLIDERECTS[type].height : this.height
      };
      this.gotoAndPlay(this.facingRight ? 'move_h' : 'move');
    }

    Enemy.prototype.update = function(delta) {
      switch (this.type) {
        case Enemy.ENEMY_SLIME:
          this.vX = this.moveSpeed * (this.facingRight ? 1 : -1);
          break;
        case Enemy.ENEMY_FLY:
          this.tweenMove(delta);
      }
      if (this.animation !== (this.facingRight ? 'move_h' : 'move')) {
        this.gotoAndPlay((this.facingRight ? 'move_h' : 'move'));
      }
      if (this.isDead) {
        return this.gotoAndStop('dead');
      }
    };

    Enemy.prototype.collideSide = function() {
      if (this.type === Enemy.ENEMY_SLIME) {
        return this.facingRight = !this.facingRight;
      }
    };

    Enemy.prototype.collideGround = function() {};

    Enemy.prototype.canCollide = function(other) {
      return !this.isDead;
    };

    Enemy.prototype.collide = function(other) {
      var dx, dy;
      if (other instanceof VAS.Player) {
        dx = dy = 0;
        if (this.y + this.height * 0.5 > other.y + other.height * 0.5) {
          dy = other.y + other.height - this.y;
        } else {
          dy = other.y - this.y - this.height;
        }
        if (this.x + this.width * 0.5 > other.x + other.width * 0.5) {
          dx = this.x - other.x - other.width;
        } else {
          dx = this.x + this.width - other.x;
        }
        if (Math.abs(dy) < Math.abs(dx)) {
          if (dy > 0 && other.vY > 0) {
            this.die();
            other.jump();
          } else {
            other.bop(dx >= 0);
          }
        } else {
          other.bop(dx >= 0);
        }
        false;
      }
      return true;
    };

    Enemy.prototype.tweenMove = function(delta) {
      if (this.isDead) {
        return;
      }
      this.pausetimer -= delta * 1000;
      this.movetimer -= delta * 1000;
      if (this.pausetimer <= 0 && this.movetimer <= 0) {
        this.movetimer = 3000;
        this.pausetimer = 500;
        this.goingDown = !this.goingDown;
      } else {
        this.vY = 0;
      }
      if (this.movetimer <= 0) {
        return this.pausetimer = this.pausetime;
      } else {
        return this.vY = this.moveSpeed * (this.goingDown ? 1 : -1);
      }
    };

    Enemy.prototype.die = function() {
      this.isDead = true;
      this.nogravity = false;
      return this.vY = -200;
    };

    return Enemy;

  })(createjs.BitmapAnimation);

}).call(this);

/*
//@ sourceMappingURL=Enemy.map
*/
